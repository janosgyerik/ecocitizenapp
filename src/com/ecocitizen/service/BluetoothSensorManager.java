/*
 * Copyright (C) 2010 Mobile Environmental Sensing For Sustainable Cities
 *
 * This file is part of EcoCitizen.
 *
 * EcoCitizen is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * EcoCitizen is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with EcoCitizen.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.ecocitizen.service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.UUID;

import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import backport.android.bluetooth.BluetoothDevice;
import backport.android.bluetooth.BluetoothSocket;

/**
 * This class does all the work for setting up and managing Bluetooth
 * connections with other devices. It has a thread for connecting with 
 * a device, and a thread for performing data transmissions when connected.
 */
public class BluetoothSensorManager extends SensorManager {
	// Debugging
	private static final String TAG = "BluetoothSensorService";
	private static final boolean D = true;

	// Unique UUID for this application generated by uuidgen
	private static final UUID MY_UUID = UUID.fromString("0E8783DA-BB85-4225-948F-F0EAB948C5FF");

	// Member fields
	private ConnectedThread mConnectedThread;

	/**
	 * The class is for one-time use only.
	 */
	private final BluetoothDevice mDevice; 

	/**
	 * Constructor. Prepares a new session.
	 * @param handler  A Handler to send messages back to the UI Activity
	 */
	public BluetoothSensorManager(Handler handler, GpsLocationListener gpsLocationListener, 
			BluetoothDevice device) {
		mHandler = handler;
		mGpsLocationListener = gpsLocationListener;

		mSensorId = device.getAddress().replaceAll(":", "_");
		mDeviceName = device.getName();
		
		mDevice = device;
	}

	/**
	 * Start the ConnectThread to initiate a connection to a remote device.
	 */
	public boolean connect() {
		if (D) Log.d(TAG, "connecting to: " + mDevice);

		if (mConnectedThread != null) {
			Log.e(TAG, "Invalid state. You are not supposed to call connect() twice.");
			// TODO send a text message about the error
			return false;
		}
		
		// Get a BluetoothSocket for a connection with the given BluetoothDevice
		BluetoothSocket btSocket = null;
		try {
			btSocket = mDevice.createRfcommSocketToServiceRecord(MY_UUID);
		} 
		catch (IOException e) {
			Log.e(TAG, "create() failed", e);
			// TODO send a text message about the error
			return false;
		}

		// Make a connection to the BluetoothSocket
		try {
			// This is a blocking call and will only return on a
			// successful connection or an exception
			btSocket.connect();
		} 
		catch (IOException e) {
			Log.e(TAG, "btSocket.connect() failed", e);
			// TODO send a text message about the error

			// Close the socket
			try {
				btSocket.close();
			} catch (IOException e2) {
				Log.e(TAG, "unable to close() socket during connection failure", e2);
			}
			return false;
		}

		if (D) Log.d(TAG, "connected");

		// Start the thread to manage the connection and perform transmissions
		mConnectedThread = new ConnectedThread(btSocket);
		mConnectedThread.start();

		connectionSuccess(); // TODO this is just for information
		
		return true;
	}

	/**
	 * Stop all threads
	 */
	public void stop() {
		if (D) Log.d(TAG, "stop");
		if (mConnectedThread != null) mConnectedThread.shutdown();
		if (mConnectedThread != null) {mConnectedThread.cancel(); mConnectedThread = null;}

		connectionNone(); // TODO this is just for information
	}

	/**
	 * Write to the ConnectedThread in an unsynchronized manner
	 * @param out The bytes to write
	 * @see ConnectedThread#write(byte[])
	 */
	public void write(byte[] out) {
		if (mConnectedThread == null) return;
		
		// Create temporary object
		ConnectedThread r;
		// Synchronize a copy of the ConnectedThread
		synchronized (this) {
			r = mConnectedThread;
		}
		// Perform the write unsynchronized
		r.write(out);
	}

	/**
	 * This thread runs during a connection with a remote device.
	 * It handles all incoming and outgoing transmissions.
	 */
	private class ConnectedThread extends Thread {
		private final BluetoothSocket mmSocket;
		private final InputStream mmInStream;
		private final OutputStream mmOutStream;

		public ConnectedThread(BluetoothSocket socket) {
			Log.d(TAG, "create ConnectedThread");
			mmSocket = socket;
			InputStream tmpIn = null;
			OutputStream tmpOut = null;

			// Get the BluetoothSocket input and output streams
			try {
				tmpIn = socket.getInputStream();
				tmpOut = socket.getOutputStream();
			} 
			catch (IOException e) {
				Log.e(TAG, "temp sockets not created", e);
			}

			mmInStream = tmpIn;
			mmOutStream = tmpOut;
		}

		private boolean stop = false;

		public void shutdown() {
			stop = true;
			if (mmInStream != null) {
				try {
					mmInStream.close();
				} 
				catch (IOException e) {
					Log.e(TAG, "close() of InputStream failed.");
				}
			}
		}   

		public void run() {
			Log.i(TAG, "BEGIN mConnectedThread");

			BufferedReader reader = new BufferedReader(new InputStreamReader(mmInStream));

			while (! stop) {
				try {
					String line = reader.readLine();
					if (line != null) {
						Bundle bundle = getSensorDataBundle(line);
						mHandler.obtainMessage(MessageType.SENTENCE, bundle).sendToTarget();
					}
				} catch (IOException e) {
					Log.e(TAG, "disconnected", e);
					connectionLost(); // TODO make sure this cleans up the SensorManager properly
					// TODO this is MORE than just information msg, SensorManager must be removed
					break;			
				}
			}
		}

		/**
		 * Write to the connected OutStream.
		 * @param buffer  The bytes to write
		 */
		public void write(byte[] buffer) {
			try {
				mmOutStream.write(buffer);
			} 
			catch (IOException e) {
				Log.e(TAG, "Exception during write", e);
			}
		}

		public void cancel() {
			try {
				mmSocket.close();
			} 
			catch (IOException e) {
				Log.e(TAG, "close() of connect socket failed", e);
			}
		}
	}
}
