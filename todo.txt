when connected
==============
- record some sample data file with zephyr
- get a copy of the zephyr docs
	- confirm the protocol details (basically the language of Zephyr)
- upgrade an android to newer version


release in marketplace
======================
- add a property to switch debugging on/off - perhaps in props.xml?
- complete support for zephyr
- follow through the steps in android docs


current focus
=============
- bug: pollution sample causes black tree
- bug: device name is not shown when changing applications
	- maybe need to get the list of devices from the device manager service
	? use sensor id instead of name in DeviceManagerService
- bug: list of connected device names is not updated after resume
- bug: disconnect sensor and endsession seem to be sent twice to logplayer. After the fix, also clean up endSession implementation in FileSaverService
- DeviceListActivity improvement
	- make logfile device items as wide as bt ones, with two lines
	- give descriptive names to logfile resources
	- show logfile devices only in 'Debug mode'
- bug: it seems two GpsLocationListeners are created, why?
- bug: why is this:
    D/DeviceManagerClient( 2764): handleMessage 13 CO2Sample2.txt
    D/DeviceManagerClient( 2764): handleMessage 15 null
    D/DeviceManagerClient( 2764): handleMessage 13 CO2Sample2.txt
    D/DeviceManagerClient( 2764): handleMessage 15 null
- remove unique-ish ids from layout xml, they do not need to be so unique
- clean up variable visibility in .app
- add class diagram for .app
- add class diagrams to wiki with additional explanatory text


support for zephyr
==================
- record some sample binary data from zephyr
- analyze the data and the protocol docs, figure out how to formulate sentences
- create the framework of appropriate drivers to use in bluetooth readers


critical for next experiment
============================
- bug: app gets into strange state after connection lost, sending session id 'null'
- improve data uploading throughput
	test slowness, confirm and quantify
	pack multiple messages in one transmission
	repeat test, confirm improvement
	automatically adjust sending buffer size
	! an alternative solution is to use an alternative high speed uploader class


optimization
============
- make it possible to cancel upload in FileInfoWithUploadActivity
	tip: the activity is launched from FileUploaderActivity
	tip: make ProgressDialog cancelable
- add progress bar while uploading a file in FileInfoWithUploadActivity
	tip: AsyncTask.onProgressUpdate
	since we know number of lines, this should be possible
- create the foundation for detecting sensor types and using different drivers based on sensor type
	use ascii reader with senspods
	use binary reader (zephyr reader) with zephyr
	apply unit type overrides (ppm instead of V for COx from senspods)
- clean up files on android
	check on sessions that crash the app
	remove workaround code
- fix hardcoded values in debugtools
? bug: android uploader gets killed
? bug: java.net.UnknownHostException
- AddNote activity: override onSaveInstanceState method to prevent losing text when another application (like a phone call) comes to the foreground
- if and only if performance is crucial, follow the 'Designing for Performance' article in Dev Guide
- try to rewrite nested linearlayouts with relativelayout
- consider using ViewStubs
- review comments in entire code, especially service code


file uploader "nice" implementation
===================================
+ show file info card with buttons
+ Upload btn begins upload in async mode
- Cancel btn can interrupt the upload
- progress bar is updated regularly
- Close button cancels upload
+ show success/failure on completion
+ show/hide buttons on success/failure appropriately


nice to have
============
- tweet current location and measurements
- know the number of data records pending for upload
- user profiles: anon, dev, janos, ...
- FileSaverService with proper synchronization


possibly bluetooth backport bugs
================================
	cannot detect connection failure to paired device, when the paired device is off (and also when out of range?)
	when calling mmInStream.close(), keyDispatchingTimedOut happens, dumping CPU usage and other debug infos and eventually kill the application itself


